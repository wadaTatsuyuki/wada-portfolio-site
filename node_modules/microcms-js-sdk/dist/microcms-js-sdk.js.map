{"version":3,"sources":["../src/index.ts","../src/utils/parseQuery.ts","../src/utils/isCheckValue.ts","../src/utils/constants.ts","../src/lib/fetch.ts","../src/createClient.ts"],"names":["src_exports","__export","createClient","__toCommonJS","import_qs","isObject","value","isString","parseQuery","queries","qs","BASE_DOMAIN","API_VERSION","import_cross_fetch","resolveFetch","customFetch","_fetch","crossFetch","args","resolveHeadersConstructor","CrossFetchHeaders","generateFetchClient","apiKey","fetch","HeadersConstructor","req","init","headers","import_async_retry","serviceDomain","retryOption","baseUrl","makeRequest","endpoint","contentId","requestInit","fetchClient","queryString","url","getMessageFromResponse","response","message","retry","bail","error","err","num","customRequestInit","alternateField","draftKey","filters","orders","defaultQueries","totalCount","contentIds","offset","sleep","ms","resolve","isStringArray","arr","item","contents","ids","content","isDraft"],"mappings":"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","sourcesContent":["export { createClient } from './createClient';\nexport * from './types';\n","/**\n * Parse query.\n *\n * @param {object} queries\n * @return {string} queryString\n */\nimport qs from 'qs';\nimport { isObject } from './isCheckValue';\nimport { MicroCMSQueries } from '../types';\n\nexport const parseQuery = (queries: MicroCMSQueries): string => {\n  if (!isObject(queries)) {\n    throw new Error('queries is not object');\n  }\n  const queryString = qs.stringify(queries, { arrayFormat: 'comma' });\n\n  return queryString;\n};\n","/**\n * Check object\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isObject = (value: unknown): value is Record<string, unknown> => {\n  return value !== null && typeof value === 'object';\n};\n\n/**\n * Check string\n *\n * @param {unknown} value\n * @returns {boolean}\n */\nexport const isString = (value: unknown): value is string => {\n  return typeof value === 'string';\n};\n","export const BASE_DOMAIN = 'microcms.io';\nexport const API_VERSION = 'v1';\nexport const MAX_RETRY_COUNT = 2;\nexport const MIN_TIMEOUT_MS = 5000;\n","import crossFetch, { Headers as CrossFetchHeaders } from 'cross-fetch';\nimport { Fetch } from 'src/types';\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (crossFetch as unknown) as Fetch;\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\n\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return CrossFetchHeaders;\n  }\n\n  return Headers;\n};\n\nexport const generateFetchClient = (\n  apiKey: string,\n  customFetch?: Fetch\n): Fetch => {\n  const fetch = resolveFetch(customFetch);\n  const HeadersConstructor = resolveHeadersConstructor();\n\n  return async (req, init) => {\n    const headers = new HeadersConstructor(init?.headers);\n\n    if (!headers.has('X-MICROCMS-API-KEY')) {\n      headers.set('X-MICROCMS-API-KEY', apiKey);\n    }\n\n    return fetch(req, { ...init, headers });\n  };\n};\n","/**\n * microCMS API SDK\n * https://github.com/microcmsio/microcms-js-sdk\n */\nimport { parseQuery } from './utils/parseQuery';\nimport { isString } from './utils/isCheckValue';\nimport {\n  MicroCMSClient,\n  MakeRequest,\n  GetRequest,\n  GetListRequest,\n  GetListDetailRequest,\n  GetObjectRequest,\n  WriteApiRequestResult,\n  CreateRequest,\n  MicroCMSListResponse,\n  MicroCMSListContent,\n  MicroCMSObjectContent,\n  UpdateRequest,\n  DeleteRequest,\n  GetAllContentIdsRequest,\n  MicroCMSQueries,\n} from './types';\nimport {\n  API_VERSION,\n  BASE_DOMAIN,\n  MAX_RETRY_COUNT,\n  MIN_TIMEOUT_MS,\n} from './utils/constants';\nimport { generateFetchClient } from './lib/fetch';\nimport retry from 'async-retry';\n\n/**\n * Initialize SDK Client\n */\nexport const createClient = ({\n  serviceDomain,\n  apiKey,\n  customFetch,\n  retry: retryOption,\n}: MicroCMSClient) => {\n  if (!serviceDomain || !apiKey) {\n    throw new Error('parameter is required (check serviceDomain and apiKey)');\n  }\n\n  if (!isString(serviceDomain) || !isString(apiKey)) {\n    throw new Error('parameter is not string');\n  }\n\n  /**\n   * Defined microCMS base URL\n   */\n  const baseUrl = `https://${serviceDomain}.${BASE_DOMAIN}/api/${API_VERSION}`;\n\n  /**\n   * Make request\n   */\n  const makeRequest = async ({\n    endpoint,\n    contentId,\n    queries = {},\n    requestInit,\n  }: MakeRequest) => {\n    const fetchClient = generateFetchClient(apiKey, customFetch);\n    const queryString = parseQuery(queries);\n    const url = `${baseUrl}/${endpoint}${contentId ? `/${contentId}` : ''}${\n      queryString ? `?${queryString}` : ''\n    }`;\n\n    const getMessageFromResponse = async (response: Response) => {\n      // Enclose `response.json()` in a try since it may throw an error\n      // Only return the `message` if there is a `message`\n      try {\n        const { message } = await response.json();\n        return message ?? null;\n      } catch (_) {\n        return null;\n      }\n    };\n\n    return await retry(\n      async (bail) => {\n        try {\n          const response = await fetchClient(url, {\n            ...requestInit,\n            method: requestInit?.method ?? 'GET',\n          });\n\n          // If a status code in the 400 range other than 429 is returned, do not retry.\n          if (\n            response.status !== 429 &&\n            response.status >= 400 &&\n            response.status < 500\n          ) {\n            const message = await getMessageFromResponse(response);\n\n            return bail(\n              new Error(\n                `fetch API response status: ${response.status}${\n                  message ? `\\n  message is \\`${message}\\`` : ''\n                }`,\n              ),\n            );\n          }\n\n          // If the response fails with any other status code, retry until the set number of attempts is reached.\n          if (!response.ok) {\n            const message = await getMessageFromResponse(response);\n\n            return Promise.reject(\n              new Error(\n                `fetch API response status: ${response.status}${\n                  message ? `\\n  message is \\`${message}\\`` : ''\n                }`,\n              ),\n            );\n          }\n\n          if (requestInit?.method === 'DELETE') return;\n\n          return response.json();\n        } catch (error) {\n          if (error.data) {\n            throw error.data;\n          }\n\n          if (error.response?.data) {\n            throw error.response.data;\n          }\n\n          return Promise.reject(\n            new Error(`Network Error.\\n  Details: ${error}`),\n          );\n        }\n      },\n      {\n        retries: retryOption ? MAX_RETRY_COUNT : 0,\n        onRetry: (err, num) => {\n          console.log(err);\n          console.log(`Waiting for retry (${num}/${MAX_RETRY_COUNT})`);\n        },\n        minTimeout: MIN_TIMEOUT_MS,\n      },\n    );\n  };\n\n  /**\n   * Get list and object API data for microCMS\n   */\n  const get = async <T = any>({\n    endpoint,\n    contentId,\n    queries = {},\n    customRequestInit,\n  }: GetRequest): Promise<T> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get list API data for microCMS\n   */\n  const getList = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetListRequest): Promise<MicroCMSListResponse<T>> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get list API detail data for microCMS\n   */\n  const getListDetail = async <T = any>({\n    endpoint,\n    contentId,\n    queries = {},\n    customRequestInit,\n  }: GetListDetailRequest): Promise<T & MicroCMSListContent> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  /**\n   * Get object API data for microCMS\n   */\n  const getObject = async <T = any>({\n    endpoint,\n    queries = {},\n    customRequestInit,\n  }: GetObjectRequest): Promise<T & MicroCMSObjectContent> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n    return await makeRequest({\n      endpoint,\n      queries,\n      requestInit: customRequestInit,\n    });\n  };\n\n  const getAllContentIds = async ({\n    endpoint,\n    alternateField,\n    draftKey,\n    filters,\n    orders,\n    customRequestInit,\n  }: GetAllContentIdsRequest): Promise<string[]> => {\n    const limit = 100;\n    const defaultQueries: MicroCMSQueries = {\n      draftKey,\n      filters,\n      orders,\n      limit,\n      fields: alternateField ?? 'id',\n      depth: 0,\n    };\n\n    const { totalCount } = await makeRequest({\n      endpoint,\n      queries: { ...defaultQueries, limit: 0 },\n      requestInit: customRequestInit,\n    });\n\n    let contentIds: string[] = [];\n    let offset = 0;\n\n    const sleep = (ms: number) =>\n      new Promise((resolve) => setTimeout(resolve, ms));\n    const isStringArray = (arr: unknown[]): arr is string[] =>\n      arr.every((item) => typeof item === 'string');\n\n    while (contentIds.length < totalCount) {\n      const { contents } = (await makeRequest({\n        endpoint,\n        queries: { ...defaultQueries, offset },\n        requestInit: customRequestInit,\n      })) as MicroCMSListResponse<Record<string, unknown>>;\n\n      const ids = contents.map((content) => content[alternateField ?? 'id']);\n\n      if (!isStringArray(ids)) {\n        throw new Error(\n          'The value of the field specified by `alternateField` is not a string.',\n        );\n      }\n\n      contentIds = [...contentIds, ...ids];\n\n      offset += limit;\n      if (contentIds.length < totalCount) {\n        await sleep(1000); // sleep for 1 second before the next request\n      }\n    }\n\n    return contentIds;\n  };\n\n  /**\n   * Create new content in the microCMS list API data\n   */\n  const create = async <T extends Record<string | number, any>>({\n    endpoint,\n    contentId,\n    content,\n    isDraft = false,\n    customRequestInit,\n  }: CreateRequest<T>): Promise<WriteApiRequestResult> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    const queries: MakeRequest['queries'] = isDraft ? { status: 'draft' } : {};\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: contentId ? 'PUT' : 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(content),\n    };\n\n    return makeRequest({\n      endpoint,\n      contentId,\n      queries,\n      requestInit,\n    });\n  };\n\n  /**\n   * Update content in their microCMS list and object API data\n   */\n  const update = async <T extends Record<string | number, any>>({\n    endpoint,\n    contentId,\n    content,\n    customRequestInit,\n  }: UpdateRequest<T>): Promise<WriteApiRequestResult> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(content),\n    };\n\n    return makeRequest({\n      endpoint,\n      contentId,\n      requestInit,\n    });\n  };\n\n  /**\n   * Delete content in their microCMS list and object API data\n   */\n  const _delete = async ({\n    endpoint,\n    contentId,\n    customRequestInit,\n  }: DeleteRequest): Promise<void> => {\n    if (!endpoint) {\n      return Promise.reject(new Error('endpoint is required'));\n    }\n\n    if (!contentId) {\n      return Promise.reject(new Error('contentId is required'));\n    }\n\n    const requestInit: MakeRequest['requestInit'] = {\n      ...customRequestInit,\n      method: 'DELETE',\n      headers: {},\n      body: undefined,\n    };\n\n    await makeRequest({ endpoint, contentId, requestInit });\n  };\n\n  return {\n    get,\n    getList,\n    getListDetail,\n    getObject,\n    getAllContentIds,\n    create,\n    update,\n    delete: _delete,\n  };\n};\n"]}